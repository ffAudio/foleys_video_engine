<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>foleys_video_engine: libswresample</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link rel="shortcut icon" href="ff-icon.png" type="image/x-icon" />
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-115384200-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-115384200-1');
</script>
<!-- END Global site tag - Google Analytics -->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="https://foleysfinest.com"><img alt="Logo" src="Logo-FF.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">foleys_video_engine
   </div>
   <div id="projectbrief">Engine for reading / writing / editing and mixing video</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">libswresample</div>  </div>
</div><!--header-->
<div class="contents">

<p>Audio resampling, sample format conversion and mixing library.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:swresample_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="swresample_8h.html">swresample.h</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga4aa775b7fba31d2c8dc14c7b7e282863"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a></td></tr>
<tr class="memdesc:ga4aa775b7fba31d2c8dc14c7b7e282863"><td class="mdescLeft">&#160;</td><td class="mdescRight">The libswresample context.  <a href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">More...</a><br /></td></tr>
<tr class="separator:ga4aa775b7fba31d2c8dc14c7b7e282863"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6ca0298348b382cf0fe67d7f339a17f3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structAVClass.html">AVClass</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lswr.html#ga6ca0298348b382cf0fe67d7f339a17f3">swr_get_class</a> (void)</td></tr>
<tr class="memdesc:ga6ca0298348b382cf0fe67d7f339a17f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="structAVClass.html" title="Describe the class of an AVClass context structure.">AVClass</a> for SwrContext.  <a href="group__lswr.html#ga6ca0298348b382cf0fe67d7f339a17f3">More...</a><br /></td></tr>
<tr class="separator:ga6ca0298348b382cf0fe67d7f339a17f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Option constants</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpa7f26de0633f7745117b919eca2482d2"></a>These constants are used for the <a class="el" href="group__avoptions.html">AVOptions</a> interface for lswr. </p>
</td></tr>
<tr class="memitem:ga387e613b19e5269a46d9ff1a5ee3fcd4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lswr.html#ga387e613b19e5269a46d9ff1a5ee3fcd4">SwrDitherType</a> { <br />
&#160;&#160;<a class="el" href="group__lswr.html#gga387e613b19e5269a46d9ff1a5ee3fcd4afacc17a82581598f762a8036ba559836">SWR_DITHER_NONE</a> = 0, 
<a class="el" href="group__lswr.html#gga387e613b19e5269a46d9ff1a5ee3fcd4a0fec2dd28b1357b50e9807ca6ecee83a">SWR_DITHER_RECTANGULAR</a>, 
<a class="el" href="group__lswr.html#gga387e613b19e5269a46d9ff1a5ee3fcd4ae4635dc355dc680eeb211e7af17ddfd2">SWR_DITHER_TRIANGULAR</a>, 
<a class="el" href="group__lswr.html#gga387e613b19e5269a46d9ff1a5ee3fcd4a91276f2e437aa9d0d8bdffabe24f5532">SWR_DITHER_TRIANGULAR_HIGHPASS</a>, 
<br />
&#160;&#160;<a class="el" href="group__lswr.html#gga387e613b19e5269a46d9ff1a5ee3fcd4ae6858a54f5b2e1bffa9aaef20b2593c0">SWR_DITHER_NS</a> = 64, 
<a class="el" href="group__lswr.html#gga387e613b19e5269a46d9ff1a5ee3fcd4a6f6072071262f7f05a52057cfe48df87">SWR_DITHER_NS_LIPSHITZ</a>, 
<a class="el" href="group__lswr.html#gga387e613b19e5269a46d9ff1a5ee3fcd4ae197d7fc5592652aaa8edf1067c56af9">SWR_DITHER_NS_F_WEIGHTED</a>, 
<a class="el" href="group__lswr.html#gga387e613b19e5269a46d9ff1a5ee3fcd4a60eeb8ca5de47916a81f2c3a6534eed4">SWR_DITHER_NS_MODIFIED_E_WEIGHTED</a>, 
<br />
&#160;&#160;<a class="el" href="group__lswr.html#gga387e613b19e5269a46d9ff1a5ee3fcd4ad13d2ff2831d463eb46ca4c46dfec7b0">SWR_DITHER_NS_IMPROVED_E_WEIGHTED</a>, 
<a class="el" href="group__lswr.html#gga387e613b19e5269a46d9ff1a5ee3fcd4ae3aba4bf43c2210a148b11c0215b5d24">SWR_DITHER_NS_SHIBATA</a>, 
<a class="el" href="group__lswr.html#gga387e613b19e5269a46d9ff1a5ee3fcd4af275c21089abbf78a6623544f34d76f9">SWR_DITHER_NS_LOW_SHIBATA</a>, 
<a class="el" href="group__lswr.html#gga387e613b19e5269a46d9ff1a5ee3fcd4ac569828a706ccf22a8d5810c973c8f17">SWR_DITHER_NS_HIGH_SHIBATA</a>, 
<br />
&#160;&#160;<a class="el" href="group__lswr.html#gga387e613b19e5269a46d9ff1a5ee3fcd4aacbdf2f91bb14cf390116492115fb8ea">SWR_DITHER_NB</a>
<br />
 }</td></tr>
<tr class="memdesc:ga387e613b19e5269a46d9ff1a5ee3fcd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dithering algorithms.  <a href="group__lswr.html#ga387e613b19e5269a46d9ff1a5ee3fcd4">More...</a><br /></td></tr>
<tr class="separator:ga387e613b19e5269a46d9ff1a5ee3fcd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87f9e023bbe780d3ccf17dfc7abed580"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lswr.html#ga87f9e023bbe780d3ccf17dfc7abed580">SwrEngine</a> { <a class="el" href="group__lswr.html#gga87f9e023bbe780d3ccf17dfc7abed580a11652db5af0c279d79deba1c577c9729">SWR_ENGINE_SWR</a>, 
<a class="el" href="group__lswr.html#gga87f9e023bbe780d3ccf17dfc7abed580a2933f5b0b96829095a04a8acd19b27e7">SWR_ENGINE_SOXR</a>, 
<a class="el" href="group__lswr.html#gga87f9e023bbe780d3ccf17dfc7abed580a865af2e70ebb85b3cafb93f1854dbef9">SWR_ENGINE_NB</a>
 }</td></tr>
<tr class="memdesc:ga87f9e023bbe780d3ccf17dfc7abed580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resampling Engines.  <a href="group__lswr.html#ga87f9e023bbe780d3ccf17dfc7abed580">More...</a><br /></td></tr>
<tr class="separator:ga87f9e023bbe780d3ccf17dfc7abed580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2176b2a3a8b809788f6e7ccdc238b6be"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lswr.html#ga2176b2a3a8b809788f6e7ccdc238b6be">SwrFilterType</a> { <a class="el" href="group__lswr.html#gga2176b2a3a8b809788f6e7ccdc238b6bea1a6413b9888bac851e2ee4f991f01d0c">SWR_FILTER_TYPE_CUBIC</a>, 
<a class="el" href="group__lswr.html#gga2176b2a3a8b809788f6e7ccdc238b6bea17f5dd4512b4abc2285905293a81cf55">SWR_FILTER_TYPE_BLACKMAN_NUTTALL</a>, 
<a class="el" href="group__lswr.html#gga2176b2a3a8b809788f6e7ccdc238b6bea8f492a5dc94b6e41a37f190c5492bf3f">SWR_FILTER_TYPE_KAISER</a>
 }</td></tr>
<tr class="memdesc:ga2176b2a3a8b809788f6e7ccdc238b6be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resampling Filter Types.  <a href="group__lswr.html#ga2176b2a3a8b809788f6e7ccdc238b6be">More...</a><br /></td></tr>
<tr class="separator:ga2176b2a3a8b809788f6e7ccdc238b6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2226aca7f49137f3f29b6f731a985916"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lswr.html#ga2226aca7f49137f3f29b6f731a985916">SWR_FLAG_RESAMPLE</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga2226aca7f49137f3f29b6f731a985916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force resampling even if equal sample rate.  <a href="group__lswr.html#ga2226aca7f49137f3f29b6f731a985916">More...</a><br /></td></tr>
<tr class="separator:ga2226aca7f49137f3f29b6f731a985916"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
SwrContext constructor functions</h2></td></tr>
<tr class="memitem:gaf58c4ff10f73d74bdab8e5aa7193147c"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lswr.html#gaf58c4ff10f73d74bdab8e5aa7193147c">swr_alloc</a> (void)</td></tr>
<tr class="memdesc:gaf58c4ff10f73d74bdab8e5aa7193147c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate SwrContext.  <a href="group__lswr.html#gaf58c4ff10f73d74bdab8e5aa7193147c">More...</a><br /></td></tr>
<tr class="separator:gaf58c4ff10f73d74bdab8e5aa7193147c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae173e8ed91717700471a1dcd06f00f67"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lswr.html#gae173e8ed91717700471a1dcd06f00f67">swr_init</a> (struct <a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a> *s)</td></tr>
<tr class="memdesc:gae173e8ed91717700471a1dcd06f00f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize context after user parameters have been set.  <a href="group__lswr.html#gae173e8ed91717700471a1dcd06f00f67">More...</a><br /></td></tr>
<tr class="separator:gae173e8ed91717700471a1dcd06f00f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab11b02705e97404b6d74b18b2fcfdfcf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lswr.html#gab11b02705e97404b6d74b18b2fcfdfcf">swr_is_initialized</a> (struct <a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a> *s)</td></tr>
<tr class="memdesc:gab11b02705e97404b6d74b18b2fcfdfcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether an swr context has been initialized or not.  <a href="group__lswr.html#gab11b02705e97404b6d74b18b2fcfdfcf">More...</a><br /></td></tr>
<tr class="separator:gab11b02705e97404b6d74b18b2fcfdfcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7f29022726c871aadf935281a9813bc"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lswr.html#gad7f29022726c871aadf935281a9813bc">swr_alloc_set_opts</a> (struct <a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a> *s, int64_t out_ch_layout, enum <a class="el" href="group__lavu__sampfmts.html#gaf9a51ca15301871723577c730b5865c5">AVSampleFormat</a> out_sample_fmt, int out_sample_rate, int64_t in_ch_layout, enum <a class="el" href="group__lavu__sampfmts.html#gaf9a51ca15301871723577c730b5865c5">AVSampleFormat</a> in_sample_fmt, int in_sample_rate, int log_offset, void *log_ctx)</td></tr>
<tr class="memdesc:gad7f29022726c871aadf935281a9813bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate SwrContext if needed and set/reset common parameters.  <a href="group__lswr.html#gad7f29022726c871aadf935281a9813bc">More...</a><br /></td></tr>
<tr class="separator:gad7f29022726c871aadf935281a9813bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
SwrContext destructor functions</h2></td></tr>
<tr class="memitem:ga818f7d78b1ad7d8d5b70de374b668c34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lswr.html#ga818f7d78b1ad7d8d5b70de374b668c34">swr_free</a> (struct <a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a> **s)</td></tr>
<tr class="memdesc:ga818f7d78b1ad7d8d5b70de374b668c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the given SwrContext and set the pointer to NULL.  <a href="group__lswr.html#ga818f7d78b1ad7d8d5b70de374b668c34">More...</a><br /></td></tr>
<tr class="separator:ga818f7d78b1ad7d8d5b70de374b668c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4bf1048740dfc08d68aba9f1b4db22e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lswr.html#gaa4bf1048740dfc08d68aba9f1b4db22e">swr_close</a> (struct <a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a> *s)</td></tr>
<tr class="memdesc:gaa4bf1048740dfc08d68aba9f1b4db22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the context so that <a class="el" href="group__lswr.html#gab11b02705e97404b6d74b18b2fcfdfcf" title="Check whether an swr context has been initialized or not.">swr_is_initialized()</a> returns 0.  <a href="group__lswr.html#gaa4bf1048740dfc08d68aba9f1b4db22e">More...</a><br /></td></tr>
<tr class="separator:gaa4bf1048740dfc08d68aba9f1b4db22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Core conversion functions</h2></td></tr>
<tr class="memitem:gaa5bb6cab830146efa8c760fa66ee582a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lswr.html#gaa5bb6cab830146efa8c760fa66ee582a">swr_convert</a> (struct <a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a> *s, uint8_t **out, int out_count, const uint8_t **in, int in_count)</td></tr>
<tr class="memdesc:gaa5bb6cab830146efa8c760fa66ee582a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert audio.  <a href="group__lswr.html#gaa5bb6cab830146efa8c760fa66ee582a">More...</a><br /></td></tr>
<tr class="separator:gaa5bb6cab830146efa8c760fa66ee582a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad9811626c6c01a241f6bf46aff27333"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lswr.html#gaad9811626c6c01a241f6bf46aff27333">swr_next_pts</a> (struct <a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a> *s, int64_t pts)</td></tr>
<tr class="memdesc:gaad9811626c6c01a241f6bf46aff27333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the next timestamp from input to output timestamps are in 1/(in_sample_rate * out_sample_rate) units.  <a href="group__lswr.html#gaad9811626c6c01a241f6bf46aff27333">More...</a><br /></td></tr>
<tr class="separator:gaad9811626c6c01a241f6bf46aff27333"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Low-level option setting functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpf66d1ff8fedfec3d224b7f4e324f89bf"></a>These functons provide a means to set low-level options that is not possible with the <a class="el" href="group__avoptions.html#structAVOption" title="AVOption.">AVOption</a> API. </p>
</td></tr>
<tr class="memitem:gab7f21690522b85d7757e13fa9853d4d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lswr.html#gab7f21690522b85d7757e13fa9853d4d8">swr_set_compensation</a> (struct <a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a> *s, int sample_delta, int compensation_distance)</td></tr>
<tr class="memdesc:gab7f21690522b85d7757e13fa9853d4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate resampling compensation ("soft" compensation).  <a href="group__lswr.html#gab7f21690522b85d7757e13fa9853d4d8">More...</a><br /></td></tr>
<tr class="separator:gab7f21690522b85d7757e13fa9853d4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b528050b5f5b704aecbfbc257a17ef0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lswr.html#ga1b528050b5f5b704aecbfbc257a17ef0">swr_set_channel_mapping</a> (struct <a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a> *s, const int *channel_map)</td></tr>
<tr class="memdesc:ga1b528050b5f5b704aecbfbc257a17ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a customized input channel mapping.  <a href="group__lswr.html#ga1b528050b5f5b704aecbfbc257a17ef0">More...</a><br /></td></tr>
<tr class="separator:ga1b528050b5f5b704aecbfbc257a17ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0405fcd08440b3fc0165a00969582dc3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lswr.html#ga0405fcd08440b3fc0165a00969582dc3">swr_build_matrix</a> (uint64_t in_layout, uint64_t out_layout, double center_mix_level, double surround_mix_level, double lfe_mix_level, double rematrix_maxval, double rematrix_volume, double *matrix, int stride, enum <a class="el" href="group__channel__mask__c.html#gabd576ea664e3ac5d31f3362064fe13e6">AVMatrixEncoding</a> matrix_encoding, void *log_ctx)</td></tr>
<tr class="memdesc:ga0405fcd08440b3fc0165a00969582dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a channel mixing matrix.  <a href="group__lswr.html#ga0405fcd08440b3fc0165a00969582dc3">More...</a><br /></td></tr>
<tr class="separator:ga0405fcd08440b3fc0165a00969582dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9064d65b1e654dc78f7d6bcd2e8c747"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lswr.html#gaf9064d65b1e654dc78f7d6bcd2e8c747">swr_set_matrix</a> (struct <a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a> *s, const double *matrix, int stride)</td></tr>
<tr class="memdesc:gaf9064d65b1e654dc78f7d6bcd2e8c747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a customized remix matrix.  <a href="group__lswr.html#gaf9064d65b1e654dc78f7d6bcd2e8c747">More...</a><br /></td></tr>
<tr class="separator:gaf9064d65b1e654dc78f7d6bcd2e8c747"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Sample handling functions</h2></td></tr>
<tr class="memitem:ga43d7ba4507891fc25aacbbea5cdfb065"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lswr.html#ga43d7ba4507891fc25aacbbea5cdfb065">swr_drop_output</a> (struct <a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a> *s, int count)</td></tr>
<tr class="memdesc:ga43d7ba4507891fc25aacbbea5cdfb065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops the specified number of output samples.  <a href="group__lswr.html#ga43d7ba4507891fc25aacbbea5cdfb065">More...</a><br /></td></tr>
<tr class="separator:ga43d7ba4507891fc25aacbbea5cdfb065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4733ed4779ed3e30379de2a6ef8de837"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lswr.html#ga4733ed4779ed3e30379de2a6ef8de837">swr_inject_silence</a> (struct <a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a> *s, int count)</td></tr>
<tr class="memdesc:ga4733ed4779ed3e30379de2a6ef8de837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Injects the specified number of silence samples.  <a href="group__lswr.html#ga4733ed4779ed3e30379de2a6ef8de837">More...</a><br /></td></tr>
<tr class="separator:ga4733ed4779ed3e30379de2a6ef8de837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5121a5a7890a2d23b72dc871dd0ebb06"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lswr.html#ga5121a5a7890a2d23b72dc871dd0ebb06">swr_get_delay</a> (struct <a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a> *s, int64_t base)</td></tr>
<tr class="memdesc:ga5121a5a7890a2d23b72dc871dd0ebb06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the delay the next input sample will experience relative to the next output sample.  <a href="group__lswr.html#ga5121a5a7890a2d23b72dc871dd0ebb06">More...</a><br /></td></tr>
<tr class="separator:ga5121a5a7890a2d23b72dc871dd0ebb06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97a8d5f6abe3bcdfb6072412f17285a4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lswr.html#ga97a8d5f6abe3bcdfb6072412f17285a4">swr_get_out_samples</a> (struct <a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a> *s, int in_samples)</td></tr>
<tr class="memdesc:ga97a8d5f6abe3bcdfb6072412f17285a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an upper bound on the number of samples that the next swr_convert call will output, if called with in_samples of input samples.  <a href="group__lswr.html#ga97a8d5f6abe3bcdfb6072412f17285a4">More...</a><br /></td></tr>
<tr class="separator:ga97a8d5f6abe3bcdfb6072412f17285a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Configuration accessors</h2></td></tr>
<tr class="memitem:gaed39c2153a1e26b4ef656ec8c765a2e3"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lswr.html#gaed39c2153a1e26b4ef656ec8c765a2e3">swresample_version</a> (void)</td></tr>
<tr class="memdesc:gaed39c2153a1e26b4ef656ec8c765a2e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="libswresample_2version_8h.html#a6172452a08ba6386e2265bd34769982b">LIBSWRESAMPLE_VERSION_INT</a> constant.  <a href="group__lswr.html#gaed39c2153a1e26b4ef656ec8c765a2e3">More...</a><br /></td></tr>
<tr class="separator:gaed39c2153a1e26b4ef656ec8c765a2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad602fde7a824753d5adc57e7f1372e27"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lswr.html#gad602fde7a824753d5adc57e7f1372e27">swresample_configuration</a> (void)</td></tr>
<tr class="memdesc:gad602fde7a824753d5adc57e7f1372e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the swr build-time configuration.  <a href="group__lswr.html#gad602fde7a824753d5adc57e7f1372e27">More...</a><br /></td></tr>
<tr class="separator:gad602fde7a824753d5adc57e7f1372e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29c5657b18632e206a99d1ae27225499"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lswr.html#ga29c5657b18632e206a99d1ae27225499">swresample_license</a> (void)</td></tr>
<tr class="memdesc:ga29c5657b18632e206a99d1ae27225499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the swr license.  <a href="group__lswr.html#ga29c5657b18632e206a99d1ae27225499">More...</a><br /></td></tr>
<tr class="separator:ga29c5657b18632e206a99d1ae27225499"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
AVFrame based API</h2></td></tr>
<tr class="memitem:gac482028c01d95580106183aa84b0930c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lswr.html#gac482028c01d95580106183aa84b0930c">swr_convert_frame</a> (<a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a> *swr, <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *output, const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *input)</td></tr>
<tr class="memdesc:gac482028c01d95580106183aa84b0930c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the samples in the input <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> and write them to the output <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a>.  <a href="group__lswr.html#gac482028c01d95580106183aa84b0930c">More...</a><br /></td></tr>
<tr class="separator:gac482028c01d95580106183aa84b0930c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73ade2cf6934765cf518c6c917b77c76"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lswr.html#ga73ade2cf6934765cf518c6c917b77c76">swr_config_frame</a> (<a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a> *swr, const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *out, const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *in)</td></tr>
<tr class="memdesc:ga73ade2cf6934765cf518c6c917b77c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure or reconfigure the SwrContext using the information provided by the AVFrames.  <a href="group__lswr.html#ga73ade2cf6934765cf518c6c917b77c76">More...</a><br /></td></tr>
<tr class="separator:ga73ade2cf6934765cf518c6c917b77c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Audio resampling, sample format conversion and mixing library. </p>
<p>Interaction with lswr is done through SwrContext, which is allocated with <a class="el" href="group__lswr.html#gaf58c4ff10f73d74bdab8e5aa7193147c" title="Allocate SwrContext.">swr_alloc()</a> or <a class="el" href="group__lswr.html#gad7f29022726c871aadf935281a9813bc" title="Allocate SwrContext if needed and set/reset common parameters.">swr_alloc_set_opts()</a>. It is opaque, so all parameters must be set with the <a class="el" href="group__avoptions.html">AVOptions</a> API.</p>
<p>The first thing you will need to do in order to use lswr is to allocate SwrContext. This can be done with <a class="el" href="group__lswr.html#gaf58c4ff10f73d74bdab8e5aa7193147c" title="Allocate SwrContext.">swr_alloc()</a> or <a class="el" href="group__lswr.html#gad7f29022726c871aadf935281a9813bc" title="Allocate SwrContext if needed and set/reset common parameters.">swr_alloc_set_opts()</a>. If you are using the former, you must set options through the <a class="el" href="group__avoptions.html">AVOptions</a> API. The latter function provides the same feature, but it allows you to set some common options in the same statement.</p>
<p>For example the following code will setup conversion from planar float sample format to interleaved signed 16-bit integer, downsampling from 48kHz to 44.1kHz and downmixing from 5.1 channels to stereo (using the default mixing matrix). This is using the <a class="el" href="group__lswr.html#gaf58c4ff10f73d74bdab8e5aa7193147c" title="Allocate SwrContext.">swr_alloc()</a> function. </p><div class="fragment"><div class="line"><a class="code" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a> *swr = <a class="code" href="group__lswr.html#gaf58c4ff10f73d74bdab8e5aa7193147c">swr_alloc</a>();</div>
<div class="line"><a class="code" href="group__opt__set__funcs.html#gaf25f11e11068f2c41197ba072f25d2a4">av_opt_set_channel_layout</a>(swr, <span class="stringliteral">&quot;in_channel_layout&quot;</span>,  <a class="code" href="group__channel__mask__c.html#gac36a042dc21866f9043ce930f300d0df">AV_CH_LAYOUT_5POINT1</a>, 0);</div>
<div class="line"><a class="code" href="group__opt__set__funcs.html#gaf25f11e11068f2c41197ba072f25d2a4">av_opt_set_channel_layout</a>(swr, <span class="stringliteral">&quot;out_channel_layout&quot;</span>, <a class="code" href="group__channel__mask__c.html#gabc6d6651bba254cd0fa2c42a57228e65">AV_CH_LAYOUT_STEREO</a>,  0);</div>
<div class="line"><a class="code" href="group__opt__set__funcs.html#ga3adf7185c21cc080890a5ec02c2e56b2">av_opt_set_int</a>(swr, <span class="stringliteral">&quot;in_sample_rate&quot;</span>,     48000,                0);</div>
<div class="line"><a class="code" href="group__opt__set__funcs.html#ga3adf7185c21cc080890a5ec02c2e56b2">av_opt_set_int</a>(swr, <span class="stringliteral">&quot;out_sample_rate&quot;</span>,    44100,                0);</div>
<div class="line"><a class="code" href="group__opt__set__funcs.html#gad446f7a7b92442e464d43e400e661040">av_opt_set_sample_fmt</a>(swr, <span class="stringliteral">&quot;in_sample_fmt&quot;</span>,  <a class="code" href="group__lavu__sampfmts.html#ggaf9a51ca15301871723577c730b5865c5a2d21c520e4ab21100b6440ec2d81ba1b">AV_SAMPLE_FMT_FLTP</a>, 0);</div>
<div class="line"><a class="code" href="group__opt__set__funcs.html#gad446f7a7b92442e464d43e400e661040">av_opt_set_sample_fmt</a>(swr, <span class="stringliteral">&quot;out_sample_fmt&quot;</span>, <a class="code" href="group__lavu__sampfmts.html#ggaf9a51ca15301871723577c730b5865c5aea6132df57aebc3f76e10665395c46af">AV_SAMPLE_FMT_S16</a>,  0);</div>
</div><!-- fragment --><p>The same job can be done using <a class="el" href="group__lswr.html#gad7f29022726c871aadf935281a9813bc" title="Allocate SwrContext if needed and set/reset common parameters.">swr_alloc_set_opts()</a> as well: </p><div class="fragment"><div class="line"><a class="code" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a> *swr = <a class="code" href="group__lswr.html#gad7f29022726c871aadf935281a9813bc">swr_alloc_set_opts</a>(NULL,  <span class="comment">// we&#39;re allocating a new context</span></div>
<div class="line">                      <a class="code" href="group__channel__mask__c.html#gabc6d6651bba254cd0fa2c42a57228e65">AV_CH_LAYOUT_STEREO</a>,  <span class="comment">// out_ch_layout</span></div>
<div class="line">                      <a class="code" href="group__lavu__sampfmts.html#ggaf9a51ca15301871723577c730b5865c5aea6132df57aebc3f76e10665395c46af">AV_SAMPLE_FMT_S16</a>,    <span class="comment">// out_sample_fmt</span></div>
<div class="line">                      44100,                <span class="comment">// out_sample_rate</span></div>
<div class="line">                      <a class="code" href="group__channel__mask__c.html#gac36a042dc21866f9043ce930f300d0df">AV_CH_LAYOUT_5POINT1</a>, <span class="comment">// in_ch_layout</span></div>
<div class="line">                      <a class="code" href="group__lavu__sampfmts.html#ggaf9a51ca15301871723577c730b5865c5a2d21c520e4ab21100b6440ec2d81ba1b">AV_SAMPLE_FMT_FLTP</a>,   <span class="comment">// in_sample_fmt</span></div>
<div class="line">                      48000,                <span class="comment">// in_sample_rate</span></div>
<div class="line">                      0,                    <span class="comment">// log_offset</span></div>
<div class="line">                      NULL);                <span class="comment">// log_ctx</span></div>
</div><!-- fragment --><p>Once all values have been set, it must be initialized with <a class="el" href="group__lswr.html#gae173e8ed91717700471a1dcd06f00f67" title="Initialize context after user parameters have been set.">swr_init()</a>. If you need to change the conversion parameters, you can change the parameters using AVOptions, as described above in the first example; or by using <a class="el" href="group__lswr.html#gad7f29022726c871aadf935281a9813bc" title="Allocate SwrContext if needed and set/reset common parameters.">swr_alloc_set_opts()</a>, but with the first argument the allocated context. You must then call <a class="el" href="group__lswr.html#gae173e8ed91717700471a1dcd06f00f67" title="Initialize context after user parameters have been set.">swr_init()</a> again.</p>
<p>The conversion itself is done by repeatedly calling <a class="el" href="group__lswr.html#gaa5bb6cab830146efa8c760fa66ee582a" title="Convert audio.">swr_convert()</a>. Note that the samples may get buffered in swr if you provide insufficient output space or if sample rate conversion is done, which requires "future" samples. Samples that do not require future input can be retrieved at any time by using <a class="el" href="group__lswr.html#gaa5bb6cab830146efa8c760fa66ee582a" title="Convert audio.">swr_convert()</a> (in_count can be set to 0). At the end of conversion the resampling buffer can be flushed by calling <a class="el" href="group__lswr.html#gaa5bb6cab830146efa8c760fa66ee582a" title="Convert audio.">swr_convert()</a> with NULL in and 0 in_count.</p>
<p>The samples used in the conversion process can be managed with the libavutil <a class="el" href="group__lavu__sampmanip.html">samples manipulation</a> API, including <a class="el" href="group__lavu__sampmanip.html#ga4db4c77f928d32c7d8854732f50b8c04" title="Allocate a samples buffer for nb_samples samples, and fill data pointers and linesize accordingly.">av_samples_alloc()</a> function used in the following example.</p>
<p>The delay between input and output, can at any time be found by using <a class="el" href="group__lswr.html#ga5121a5a7890a2d23b72dc871dd0ebb06" title="Gets the delay the next input sample will experience relative to the next output sample.">swr_get_delay()</a>.</p>
<p>The following code demonstrates the conversion loop assuming the parameters from above and caller-defined functions get_input() and handle_output(): </p><div class="fragment"><div class="line">uint8_t **input;</div>
<div class="line"><span class="keywordtype">int</span> in_samples;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span> (get_input(&amp;input, &amp;in_samples)) {</div>
<div class="line">    uint8_t *output;</div>
<div class="line">    <span class="keywordtype">int</span> out_samples = <a class="code" href="group__lavu__math.html#ga82d40664213508918093822461cc597e">av_rescale_rnd</a>(<a class="code" href="group__lswr.html#ga5121a5a7890a2d23b72dc871dd0ebb06">swr_get_delay</a>(swr, 48000) +</div>
<div class="line">                                     in_samples, 44100, 48000, <a class="code" href="group__lavu__math.html#gga921d656eaf2c4d6800a734a13af021d0aa1d28e08e2f8b49b256e056f93038c1a">AV_ROUND_UP</a>);</div>
<div class="line">    <a class="code" href="group__lavu__sampmanip.html#ga4db4c77f928d32c7d8854732f50b8c04">av_samples_alloc</a>(&amp;output, NULL, 2, out_samples,</div>
<div class="line">                     <a class="code" href="group__lavu__sampfmts.html#ggaf9a51ca15301871723577c730b5865c5aea6132df57aebc3f76e10665395c46af">AV_SAMPLE_FMT_S16</a>, 0);</div>
<div class="line">    out_samples = <a class="code" href="group__lswr.html#gaa5bb6cab830146efa8c760fa66ee582a">swr_convert</a>(swr, &amp;output, out_samples,</div>
<div class="line">                                     input, in_samples);</div>
<div class="line">    handle_output(output, out_samples);</div>
<div class="line">    <a class="code" href="group__lavu__mem__funcs.html#ga0cc84043ea2167ad005c86e11d0bcdba">av_freep</a>(&amp;output);</div>
<div class="line">}</div>
</div><!-- fragment --><p>When the conversion is finished, the conversion context and everything associated with it must be freed with <a class="el" href="group__lswr.html#ga818f7d78b1ad7d8d5b70de374b668c34" title="Free the given SwrContext and set the pointer to NULL.">swr_free()</a>. A <a class="el" href="group__lswr.html#gaa4bf1048740dfc08d68aba9f1b4db22e" title="Closes the context so that swr_is_initialized() returns 0.">swr_close()</a> function is also available, but it exists mainly for compatibility with libavresample, and is not required to be called.</p>
<p>There will be no memory leak if the data is not completely flushed before <a class="el" href="group__lswr.html#ga818f7d78b1ad7d8d5b70de374b668c34" title="Free the given SwrContext and set the pointer to NULL.">swr_free()</a>. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga2226aca7f49137f3f29b6f731a985916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2226aca7f49137f3f29b6f731a985916">&#9670;&nbsp;</a></span>SWR_FLAG_RESAMPLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SWR_FLAG_RESAMPLE&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force resampling even if equal sample rate. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga4aa775b7fba31d2c8dc14c7b7e282863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4aa775b7fba31d2c8dc14c7b7e282863">&#9670;&nbsp;</a></span>SwrContext</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a> <a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The libswresample context. </p>
<p>Unlike libavcodec and libavformat, this structure is opaque. This means that if you would like to set options, you must use the <a class="el" href="group__avoptions.html">AVOptions</a> API and cannot directly set values to members of the structure. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga387e613b19e5269a46d9ff1a5ee3fcd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga387e613b19e5269a46d9ff1a5ee3fcd4">&#9670;&nbsp;</a></span>SwrDitherType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lswr.html#ga387e613b19e5269a46d9ff1a5ee3fcd4">SwrDitherType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dithering algorithms. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga387e613b19e5269a46d9ff1a5ee3fcd4afacc17a82581598f762a8036ba559836"></a>SWR_DITHER_NONE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga387e613b19e5269a46d9ff1a5ee3fcd4a0fec2dd28b1357b50e9807ca6ecee83a"></a>SWR_DITHER_RECTANGULAR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga387e613b19e5269a46d9ff1a5ee3fcd4ae4635dc355dc680eeb211e7af17ddfd2"></a>SWR_DITHER_TRIANGULAR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga387e613b19e5269a46d9ff1a5ee3fcd4a91276f2e437aa9d0d8bdffabe24f5532"></a>SWR_DITHER_TRIANGULAR_HIGHPASS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga387e613b19e5269a46d9ff1a5ee3fcd4ae6858a54f5b2e1bffa9aaef20b2593c0"></a>SWR_DITHER_NS&#160;</td><td class="fielddoc"><p>not part of API/ABI </p>
</td></tr>
<tr><td class="fieldname"><a id="gga387e613b19e5269a46d9ff1a5ee3fcd4a6f6072071262f7f05a52057cfe48df87"></a>SWR_DITHER_NS_LIPSHITZ&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga387e613b19e5269a46d9ff1a5ee3fcd4ae197d7fc5592652aaa8edf1067c56af9"></a>SWR_DITHER_NS_F_WEIGHTED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga387e613b19e5269a46d9ff1a5ee3fcd4a60eeb8ca5de47916a81f2c3a6534eed4"></a>SWR_DITHER_NS_MODIFIED_E_WEIGHTED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga387e613b19e5269a46d9ff1a5ee3fcd4ad13d2ff2831d463eb46ca4c46dfec7b0"></a>SWR_DITHER_NS_IMPROVED_E_WEIGHTED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga387e613b19e5269a46d9ff1a5ee3fcd4ae3aba4bf43c2210a148b11c0215b5d24"></a>SWR_DITHER_NS_SHIBATA&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga387e613b19e5269a46d9ff1a5ee3fcd4af275c21089abbf78a6623544f34d76f9"></a>SWR_DITHER_NS_LOW_SHIBATA&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga387e613b19e5269a46d9ff1a5ee3fcd4ac569828a706ccf22a8d5810c973c8f17"></a>SWR_DITHER_NS_HIGH_SHIBATA&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga387e613b19e5269a46d9ff1a5ee3fcd4aacbdf2f91bb14cf390116492115fb8ea"></a>SWR_DITHER_NB&#160;</td><td class="fielddoc"><p>not part of API/ABI </p>
</td></tr>
</table>

</div>
</div>
<a id="ga87f9e023bbe780d3ccf17dfc7abed580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87f9e023bbe780d3ccf17dfc7abed580">&#9670;&nbsp;</a></span>SwrEngine</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lswr.html#ga87f9e023bbe780d3ccf17dfc7abed580">SwrEngine</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resampling Engines. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga87f9e023bbe780d3ccf17dfc7abed580a11652db5af0c279d79deba1c577c9729"></a>SWR_ENGINE_SWR&#160;</td><td class="fielddoc"><p>SW Resampler. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga87f9e023bbe780d3ccf17dfc7abed580a2933f5b0b96829095a04a8acd19b27e7"></a>SWR_ENGINE_SOXR&#160;</td><td class="fielddoc"><p>SoX Resampler. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga87f9e023bbe780d3ccf17dfc7abed580a865af2e70ebb85b3cafb93f1854dbef9"></a>SWR_ENGINE_NB&#160;</td><td class="fielddoc"><p>not part of API/ABI </p>
</td></tr>
</table>

</div>
</div>
<a id="ga2176b2a3a8b809788f6e7ccdc238b6be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2176b2a3a8b809788f6e7ccdc238b6be">&#9670;&nbsp;</a></span>SwrFilterType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lswr.html#ga2176b2a3a8b809788f6e7ccdc238b6be">SwrFilterType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resampling Filter Types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga2176b2a3a8b809788f6e7ccdc238b6bea1a6413b9888bac851e2ee4f991f01d0c"></a>SWR_FILTER_TYPE_CUBIC&#160;</td><td class="fielddoc"><p>Cubic. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2176b2a3a8b809788f6e7ccdc238b6bea17f5dd4512b4abc2285905293a81cf55"></a>SWR_FILTER_TYPE_BLACKMAN_NUTTALL&#160;</td><td class="fielddoc"><p>Blackman Nuttall windowed sinc. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2176b2a3a8b809788f6e7ccdc238b6bea8f492a5dc94b6e41a37f190c5492bf3f"></a>SWR_FILTER_TYPE_KAISER&#160;</td><td class="fielddoc"><p>Kaiser windowed sinc. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga6ca0298348b382cf0fe67d7f339a17f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ca0298348b382cf0fe67d7f339a17f3">&#9670;&nbsp;</a></span>swr_get_class()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structAVClass.html">AVClass</a>* swr_get_class </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="structAVClass.html" title="Describe the class of an AVClass context structure.">AVClass</a> for SwrContext. </p>
<p>It can be used in combination with AV_OPT_SEARCH_FAKE_OBJ for examining options.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__avoptions.html#gae31ae7fb20113b00108d0ecf53f25664" title="Look for an option in an object.">av_opt_find()</a>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="structAVClass.html" title="Describe the class of an AVClass context structure.">AVClass</a> of SwrContext </dd></dl>

</div>
</div>
<a id="gaf58c4ff10f73d74bdab8e5aa7193147c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf58c4ff10f73d74bdab8e5aa7193147c">&#9670;&nbsp;</a></span>swr_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a>* swr_alloc </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate SwrContext. </p>
<p>If you use this function you will need to set the parameters (manually or with <a class="el" href="group__lswr.html#gad7f29022726c871aadf935281a9813bc" title="Allocate SwrContext if needed and set/reset common parameters.">swr_alloc_set_opts()</a>) before calling <a class="el" href="group__lswr.html#gae173e8ed91717700471a1dcd06f00f67" title="Initialize context after user parameters have been set.">swr_init()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__lswr.html#gad7f29022726c871aadf935281a9813bc" title="Allocate SwrContext if needed and set/reset common parameters.">swr_alloc_set_opts()</a>, <a class="el" href="group__lswr.html#gae173e8ed91717700471a1dcd06f00f67" title="Initialize context after user parameters have been set.">swr_init()</a>, <a class="el" href="group__lswr.html#ga818f7d78b1ad7d8d5b70de374b668c34" title="Free the given SwrContext and set the pointer to NULL.">swr_free()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on error, allocated context otherwise </dd></dl>

<p class="reference">Referenced by <a class="el" href="resampling__audio_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>.</p>

</div>
</div>
<a id="gae173e8ed91717700471a1dcd06f00f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae173e8ed91717700471a1dcd06f00f67">&#9670;&nbsp;</a></span>swr_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int swr_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize context after user parameters have been set. </p>
<dl class="section note"><dt>Note</dt><dd>The context must be configured using the <a class="el" href="group__avoptions.html#structAVOption" title="AVOption.">AVOption</a> API.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__opt__set__funcs.html#ga3adf7185c21cc080890a5ec02c2e56b2">av_opt_set_int()</a> </dd>
<dd>
<a class="el" href="group__avoptions.html#gaf1a88e8f152d7835f111b1ef8813fb2e" title="Set all the options from a given dictionary on an object.">av_opt_set_dict()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">s</td><td>Swr context to initialize </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AVERROR error code in case of failure. </dd></dl>

<p class="reference">Referenced by <a class="el" href="resampling__audio_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>.</p>

</div>
</div>
<a id="gab11b02705e97404b6d74b18b2fcfdfcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab11b02705e97404b6d74b18b2fcfdfcf">&#9670;&nbsp;</a></span>swr_is_initialized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int swr_is_initialized </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether an swr context has been initialized or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Swr context to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__lswr.html#gae173e8ed91717700471a1dcd06f00f67" title="Initialize context after user parameters have been set.">swr_init()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>positive if it has been initialized, 0 if not initialized </dd></dl>

</div>
</div>
<a id="gad7f29022726c871aadf935281a9813bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7f29022726c871aadf935281a9813bc">&#9670;&nbsp;</a></span>swr_alloc_set_opts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a>* swr_alloc_set_opts </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>out_ch_layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__lavu__sampfmts.html#gaf9a51ca15301871723577c730b5865c5">AVSampleFormat</a>&#160;</td>
          <td class="paramname"><em>out_sample_fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>out_sample_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>in_ch_layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__lavu__sampfmts.html#gaf9a51ca15301871723577c730b5865c5">AVSampleFormat</a>&#160;</td>
          <td class="paramname"><em>in_sample_fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>in_sample_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>log_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>log_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate SwrContext if needed and set/reset common parameters. </p>
<p>This function does not require s to be allocated with <a class="el" href="group__lswr.html#gaf58c4ff10f73d74bdab8e5aa7193147c" title="Allocate SwrContext.">swr_alloc()</a>. On the other hand, <a class="el" href="group__lswr.html#gaf58c4ff10f73d74bdab8e5aa7193147c" title="Allocate SwrContext.">swr_alloc()</a> can use <a class="el" href="group__lswr.html#gad7f29022726c871aadf935281a9813bc" title="Allocate SwrContext if needed and set/reset common parameters.">swr_alloc_set_opts()</a> to set the parameters on the allocated context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>existing Swr context if available, or NULL if not </td></tr>
    <tr><td class="paramname">out_ch_layout</td><td>output channel layout (AV_CH_LAYOUT_*) </td></tr>
    <tr><td class="paramname">out_sample_fmt</td><td>output sample format (AV_SAMPLE_FMT_*). </td></tr>
    <tr><td class="paramname">out_sample_rate</td><td>output sample rate (frequency in Hz) </td></tr>
    <tr><td class="paramname">in_ch_layout</td><td>input channel layout (AV_CH_LAYOUT_*) </td></tr>
    <tr><td class="paramname">in_sample_fmt</td><td>input sample format (AV_SAMPLE_FMT_*). </td></tr>
    <tr><td class="paramname">in_sample_rate</td><td>input sample rate (frequency in Hz) </td></tr>
    <tr><td class="paramname">log_offset</td><td>logging level offset </td></tr>
    <tr><td class="paramname">log_ctx</td><td>parent logging context, can be NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__lswr.html#gae173e8ed91717700471a1dcd06f00f67" title="Initialize context after user parameters have been set.">swr_init()</a>, <a class="el" href="group__lswr.html#ga818f7d78b1ad7d8d5b70de374b668c34" title="Free the given SwrContext and set the pointer to NULL.">swr_free()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on error, allocated context otherwise </dd></dl>

</div>
</div>
<a id="ga818f7d78b1ad7d8d5b70de374b668c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga818f7d78b1ad7d8d5b70de374b668c34">&#9670;&nbsp;</a></span>swr_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void swr_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a> **&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the given SwrContext and set the pointer to NULL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>a pointer to a pointer to Swr context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa4bf1048740dfc08d68aba9f1b4db22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4bf1048740dfc08d68aba9f1b4db22e">&#9670;&nbsp;</a></span>swr_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void swr_close </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the context so that <a class="el" href="group__lswr.html#gab11b02705e97404b6d74b18b2fcfdfcf" title="Check whether an swr context has been initialized or not.">swr_is_initialized()</a> returns 0. </p>
<p>The context can be brought back to life by running <a class="el" href="group__lswr.html#gae173e8ed91717700471a1dcd06f00f67" title="Initialize context after user parameters have been set.">swr_init()</a>, <a class="el" href="group__lswr.html#gae173e8ed91717700471a1dcd06f00f67" title="Initialize context after user parameters have been set.">swr_init()</a> can also be used without <a class="el" href="group__lswr.html#gaa4bf1048740dfc08d68aba9f1b4db22e" title="Closes the context so that swr_is_initialized() returns 0.">swr_close()</a>. This function is mainly provided for simplifying the usecase where one tries to support libavresample and libswresample.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">s</td><td>Swr context to be closed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa5bb6cab830146efa8c760fa66ee582a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5bb6cab830146efa8c760fa66ee582a">&#9670;&nbsp;</a></span>swr_convert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int swr_convert </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t **&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>out_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t **&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>in_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert audio. </p>
<p>in and in_count can be set to 0 to flush the last few samples out at the end.</p>
<p>If more input is provided than output space, then the input will be buffered. You can avoid this buffering by using <a class="el" href="group__lswr.html#ga97a8d5f6abe3bcdfb6072412f17285a4" title="Find an upper bound on the number of samples that the next swr_convert call will output,...">swr_get_out_samples()</a> to retrieve an upper bound on the required number of output samples for the given number of input samples. Conversion will run directly without copying whenever possible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>allocated Swr context, with parameters set </td></tr>
    <tr><td class="paramname">out</td><td>output buffers, only the first one need be set in case of packed audio </td></tr>
    <tr><td class="paramname">out_count</td><td>amount of space available for output in samples per channel </td></tr>
    <tr><td class="paramname">in</td><td>input buffers, only the first one need to be set in case of packed audio </td></tr>
    <tr><td class="paramname">in_count</td><td>number of input samples available in one channel</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of samples output per channel, negative value on error </dd></dl>

</div>
</div>
<a id="gaad9811626c6c01a241f6bf46aff27333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad9811626c6c01a241f6bf46aff27333">&#9670;&nbsp;</a></span>swr_next_pts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t swr_next_pts </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>pts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the next timestamp from input to output timestamps are in 1/(in_sample_rate * out_sample_rate) units. </p>
<dl class="section note"><dt>Note</dt><dd>There are 2 slightly differently behaving modes. <ul>
<li>When automatic timestamp compensation is not used, (min_compensation &gt;= FLT_MAX) in this case timestamps will be passed through with delays compensated </li>
<li>When automatic timestamp compensation is used, (min_compensation &lt; FLT_MAX) in this case the output timestamps will match output sample numbers. See ffmpeg-resampler(1) for the two modes of compensation.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s[in]</td><td>initialized Swr context </td></tr>
    <tr><td class="paramname">pts[in]</td><td>timestamp for the next input sample, INT64_MIN if unknown </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__lswr.html#gab7f21690522b85d7757e13fa9853d4d8" title="Activate resampling compensation (&quot;soft&quot; compensation).">swr_set_compensation()</a>, <a class="el" href="group__lswr.html#ga43d7ba4507891fc25aacbbea5cdfb065" title="Drops the specified number of output samples.">swr_drop_output()</a>, and <a class="el" href="group__lswr.html#ga4733ed4779ed3e30379de2a6ef8de837" title="Injects the specified number of silence samples.">swr_inject_silence()</a> are function <a class="el" href="fate_8txt.html#a9ea1d581bf0f30cf5356a58fe0e46333">used</a> internally for timestamp compensation. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the output timestamp for the next output sample </dd></dl>

</div>
</div>
<a id="gab7f21690522b85d7757e13fa9853d4d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7f21690522b85d7757e13fa9853d4d8">&#9670;&nbsp;</a></span>swr_set_compensation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int swr_set_compensation </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sample_delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compensation_distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Activate resampling compensation ("soft" compensation). </p>
<p>This function is internally called when needed in <a class="el" href="group__lswr.html#gaad9811626c6c01a241f6bf46aff27333" title="Convert the next timestamp from input to output timestamps are in 1/(in_sample_rate * out_sample_rate...">swr_next_pts()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">s</td><td>allocated Swr context. If it is not initialized, or SWR_FLAG_RESAMPLE is not set, <a class="el" href="group__lswr.html#gae173e8ed91717700471a1dcd06f00f67" title="Initialize context after user parameters have been set.">swr_init()</a> is called with the flag set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sample_delta</td><td>delta in PTS per sample </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compensation_distance</td><td>number of samples to compensate for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;= 0 on success, AVERROR error codes if: <ul>
<li><code>s</code> is NULL, </li>
<li><code>compensation_distance</code> is less than 0, </li>
<li><code>compensation_distance</code> is 0 but sample_delta is not, </li>
<li>compensation unsupported by resampler, or </li>
<li><a class="el" href="group__lswr.html#gae173e8ed91717700471a1dcd06f00f67" title="Initialize context after user parameters have been set.">swr_init()</a> fails when called. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga1b528050b5f5b704aecbfbc257a17ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b528050b5f5b704aecbfbc257a17ef0">&#9670;&nbsp;</a></span>swr_set_channel_mapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int swr_set_channel_mapping </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>channel_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a customized input channel mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">s</td><td>allocated Swr context, not yet initialized </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel_map</td><td>customized input channel mapping (array of channel indexes, -1 for a muted channel) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;= 0 on success, or AVERROR error code in case of failure. </dd></dl>

</div>
</div>
<a id="ga0405fcd08440b3fc0165a00969582dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0405fcd08440b3fc0165a00969582dc3">&#9670;&nbsp;</a></span>swr_build_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int swr_build_matrix </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>in_layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>out_layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>center_mix_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>surround_mix_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lfe_mix_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rematrix_maxval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rematrix_volume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__channel__mask__c.html#gabd576ea664e3ac5d31f3362064fe13e6">AVMatrixEncoding</a>&#160;</td>
          <td class="paramname"><em>matrix_encoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>log_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a channel mixing matrix. </p>
<p>This function is the one used internally by libswresample for building the default mixing matrix. It is made public just as a utility function for building custom matrices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">in_layout</td><td>input channel layout </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">out_layout</td><td>output channel layout </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">center_mix_level</td><td>mix level for the center channel </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">surround_mix_level</td><td>mix level for the surround channel(s) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lfe_mix_level</td><td>mix level for the low-frequency effects channel </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rematrix_maxval</td><td>if 1.0, coefficients will be normalized to prevent overflow. if INT_MAX, coefficients will not be normalized. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">matrix</td><td>mixing coefficients; matrix[i + stride * o] is the weight of input channel i in output channel o. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">stride</td><td>distance between adjacent input channels in the matrix array </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">matrix_encoding</td><td>matrixed stereo downmix mode (e.g. dplii) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">log_ctx</td><td>parent logging context, can be NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative AVERROR code on failure </dd></dl>

</div>
</div>
<a id="gaf9064d65b1e654dc78f7d6bcd2e8c747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9064d65b1e654dc78f7d6bcd2e8c747">&#9670;&nbsp;</a></span>swr_set_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int swr_set_matrix </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a customized remix matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>allocated Swr context, not yet initialized </td></tr>
    <tr><td class="paramname">matrix</td><td>remix coefficients; matrix[i + stride * o] is the weight of input channel i in output channel o </td></tr>
    <tr><td class="paramname">stride</td><td>offset between lines of the matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;= 0 on success, or AVERROR error code in case of failure. </dd></dl>

</div>
</div>
<a id="ga43d7ba4507891fc25aacbbea5cdfb065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43d7ba4507891fc25aacbbea5cdfb065">&#9670;&nbsp;</a></span>swr_drop_output()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int swr_drop_output </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drops the specified number of output samples. </p>
<p>This function, along with <a class="el" href="group__lswr.html#ga4733ed4779ed3e30379de2a6ef8de837" title="Injects the specified number of silence samples.">swr_inject_silence()</a>, is called by <a class="el" href="group__lswr.html#gaad9811626c6c01a241f6bf46aff27333" title="Convert the next timestamp from input to output timestamps are in 1/(in_sample_rate * out_sample_rate...">swr_next_pts()</a> if needed for "hard" compensation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>allocated Swr context </td></tr>
    <tr><td class="paramname">count</td><td>number of samples to be dropped</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;= 0 on success, or a negative AVERROR code on failure </dd></dl>

</div>
</div>
<a id="ga4733ed4779ed3e30379de2a6ef8de837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4733ed4779ed3e30379de2a6ef8de837">&#9670;&nbsp;</a></span>swr_inject_silence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int swr_inject_silence </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Injects the specified number of silence samples. </p>
<p>This function, along with <a class="el" href="group__lswr.html#ga43d7ba4507891fc25aacbbea5cdfb065" title="Drops the specified number of output samples.">swr_drop_output()</a>, is called by <a class="el" href="group__lswr.html#gaad9811626c6c01a241f6bf46aff27333" title="Convert the next timestamp from input to output timestamps are in 1/(in_sample_rate * out_sample_rate...">swr_next_pts()</a> if needed for "hard" compensation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>allocated Swr context </td></tr>
    <tr><td class="paramname">count</td><td>number of samples to be dropped</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;= 0 on success, or a negative AVERROR code on failure </dd></dl>

</div>
</div>
<a id="ga5121a5a7890a2d23b72dc871dd0ebb06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5121a5a7890a2d23b72dc871dd0ebb06">&#9670;&nbsp;</a></span>swr_get_delay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t swr_get_delay </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the delay the next input sample will experience relative to the next output sample. </p>
<p>Swresample can buffer data if more input has been provided than available output space, also converting between sample rates needs a delay. This function returns the sum of all such delays. The exact delay is not necessarily an integer value in either input or output sample rate. Especially when downsampling by a large value, the output sample rate may be a poor choice to represent the delay, similarly for upsampling and the input sample rate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>swr context </td></tr>
    <tr><td class="paramname">base</td><td>timebase in which the returned delay will be: <ul>
<li>if it's set to 1 the returned delay is in seconds </li>
<li>if it's set to 1000 the returned delay is in milliseconds </li>
<li>if it's set to the input sample rate then the returned delay is in input samples </li>
<li>if it's set to the output sample rate then the returned delay is in output samples </li>
<li>if it's the least common multiple of in_sample_rate and out_sample_rate then an exact rounding-free delay will be returned </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the delay in 1 / <code>base</code> units. </dd></dl>

</div>
</div>
<a id="ga97a8d5f6abe3bcdfb6072412f17285a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97a8d5f6abe3bcdfb6072412f17285a4">&#9670;&nbsp;</a></span>swr_get_out_samples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int swr_get_out_samples </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>in_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an upper bound on the number of samples that the next swr_convert call will output, if called with in_samples of input samples. </p>
<p>This depends on the internal state, and anything changing the internal state (like further <a class="el" href="group__lswr.html#gaa5bb6cab830146efa8c760fa66ee582a" title="Convert audio.">swr_convert()</a> calls) will may change the number of samples <a class="el" href="group__lswr.html#ga97a8d5f6abe3bcdfb6072412f17285a4" title="Find an upper bound on the number of samples that the next swr_convert call will output,...">swr_get_out_samples()</a> returns for the same number of input samples.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_samples</td><td>number of input samples. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>any call to <a class="el" href="group__lswr.html#ga4733ed4779ed3e30379de2a6ef8de837" title="Injects the specified number of silence samples.">swr_inject_silence()</a>, <a class="el" href="group__lswr.html#gaa5bb6cab830146efa8c760fa66ee582a" title="Convert audio.">swr_convert()</a>, <a class="el" href="group__lswr.html#gaad9811626c6c01a241f6bf46aff27333" title="Convert the next timestamp from input to output timestamps are in 1/(in_sample_rate * out_sample_rate...">swr_next_pts()</a> or <a class="el" href="group__lswr.html#gab7f21690522b85d7757e13fa9853d4d8" title="Activate resampling compensation (&quot;soft&quot; compensation).">swr_set_compensation()</a> invalidates this limit </dd>
<dd>
it is recommended to pass the correct available buffer size to all functions like <a class="el" href="group__lswr.html#gaa5bb6cab830146efa8c760fa66ee582a" title="Convert audio.">swr_convert()</a> even if <a class="el" href="group__lswr.html#ga97a8d5f6abe3bcdfb6072412f17285a4" title="Find an upper bound on the number of samples that the next swr_convert call will output,...">swr_get_out_samples()</a> indicates that less would be used. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an upper bound on the number of samples that the next swr_convert will output or a negative value to indicate an error </dd></dl>

</div>
</div>
<a id="gaed39c2153a1e26b4ef656ec8c765a2e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed39c2153a1e26b4ef656ec8c765a2e3">&#9670;&nbsp;</a></span>swresample_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned swresample_version </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the <a class="el" href="libswresample_2version_8h.html#a6172452a08ba6386e2265bd34769982b">LIBSWRESAMPLE_VERSION_INT</a> constant. </p>
<p>This is useful to check if the build-time libswresample has the same version as the run-time one.</p>
<dl class="section return"><dt>Returns</dt><dd>the unsigned int-typed version </dd></dl>

</div>
</div>
<a id="gad602fde7a824753d5adc57e7f1372e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad602fde7a824753d5adc57e7f1372e27">&#9670;&nbsp;</a></span>swresample_configuration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* swresample_configuration </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the swr build-time configuration. </p>
<dl class="section return"><dt>Returns</dt><dd>the build-time <code></code>./configure flags </dd></dl>

</div>
</div>
<a id="ga29c5657b18632e206a99d1ae27225499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29c5657b18632e206a99d1ae27225499">&#9670;&nbsp;</a></span>swresample_license()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* swresample_license </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the swr license. </p>
<dl class="section return"><dt>Returns</dt><dd>the license of libswresample, determined at build-time </dd></dl>

</div>
</div>
<a id="gac482028c01d95580106183aa84b0930c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac482028c01d95580106183aa84b0930c">&#9670;&nbsp;</a></span>swr_convert_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int swr_convert_frame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a> *&#160;</td>
          <td class="paramname"><em>swr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the samples in the input <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> and write them to the output <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a>. </p>
<p>Input and output AVFrames must have channel_layout, sample_rate and format set.</p>
<p>If the output <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> does not have the data pointers allocated the nb_samples field will be set using <a class="el" href="group__lavu__frame.html#ga6b1acbfa82c79bf7fd78d868572f0ceb" title="Allocate new buffer(s) for audio or video data.">av_frame_get_buffer()</a> is called to allocate the frame.</p>
<p>The output <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> can be NULL or have fewer allocated samples than required. In this case, any remaining samples not written to the output will be added to an internal FIFO buffer, to be returned at the next call to this function or to <a class="el" href="group__lswr.html#gaa5bb6cab830146efa8c760fa66ee582a" title="Convert audio.">swr_convert()</a>.</p>
<p>If converting sample rate, there may be data remaining in the internal resampling delay buffer. <a class="el" href="group__lswr.html#ga5121a5a7890a2d23b72dc871dd0ebb06" title="Gets the delay the next input sample will experience relative to the next output sample.">swr_get_delay()</a> tells the number of remaining samples. To get this data as output, call this function or <a class="el" href="group__lswr.html#gaa5bb6cab830146efa8c760fa66ee582a" title="Convert audio.">swr_convert()</a> with NULL input.</p>
<p>If the SwrContext configuration does not match the output and input <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> settings the conversion does not take place and depending on which <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> is not matching AVERROR_OUTPUT_CHANGED, AVERROR_INPUT_CHANGED or the result of a bitwise-OR of them is returned.</p>
<dl class="section see"><dt>See also</dt><dd>swr_delay() </dd>
<dd>
<a class="el" href="group__lswr.html#gaa5bb6cab830146efa8c760fa66ee582a" title="Convert audio.">swr_convert()</a> </dd>
<dd>
<a class="el" href="group__lswr.html#ga5121a5a7890a2d23b72dc871dd0ebb06" title="Gets the delay the next input sample will experience relative to the next output sample.">swr_get_delay()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swr</td><td>audio resample context </td></tr>
    <tr><td class="paramname">output</td><td>output <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> </td></tr>
    <tr><td class="paramname">input</td><td>input <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, AVERROR on failure or nonmatching configuration. </dd></dl>

</div>
</div>
<a id="ga73ade2cf6934765cf518c6c917b77c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73ade2cf6934765cf518c6c917b77c76">&#9670;&nbsp;</a></span>swr_config_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int swr_config_frame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a> *&#160;</td>
          <td class="paramname"><em>swr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure or reconfigure the SwrContext using the information provided by the AVFrames. </p>
<p>The original resampling context is reset even on failure. The function calls <a class="el" href="group__lswr.html#gaa4bf1048740dfc08d68aba9f1b4db22e" title="Closes the context so that swr_is_initialized() returns 0.">swr_close()</a> internally if the context is open.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__lswr.html#gaa4bf1048740dfc08d68aba9f1b4db22e" title="Closes the context so that swr_is_initialized() returns 0.">swr_close()</a>;</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swr</td><td>audio resample context </td></tr>
    <tr><td class="paramname">output</td><td>output <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> </td></tr>
    <tr><td class="paramname">input</td><td>input <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, AVERROR on failure. </dd></dl>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="agroup__lavu__sampfmts_html_ggaf9a51ca15301871723577c730b5865c5a2d21c520e4ab21100b6440ec2d81ba1b"><div class="ttname"><a href="group__lavu__sampfmts.html#ggaf9a51ca15301871723577c730b5865c5a2d21c520e4ab21100b6440ec2d81ba1b">AV_SAMPLE_FMT_FLTP</a></div><div class="ttdeci">@ AV_SAMPLE_FMT_FLTP</div><div class="ttdoc">float, planar</div><div class="ttdef"><b>Definition:</b> samplefmt.h:69</div></div>
<div class="ttc" id="agroup__lavu__sampmanip_html_ga4db4c77f928d32c7d8854732f50b8c04"><div class="ttname"><a href="group__lavu__sampmanip.html#ga4db4c77f928d32c7d8854732f50b8c04">av_samples_alloc</a></div><div class="ttdeci">int av_samples_alloc(uint8_t **audio_data, int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)</div><div class="ttdoc">Allocate a samples buffer for nb_samples samples, and fill data pointers and linesize accordingly.</div></div>
<div class="ttc" id="agroup__lavu__math_html_gga921d656eaf2c4d6800a734a13af021d0aa1d28e08e2f8b49b256e056f93038c1a"><div class="ttname"><a href="group__lavu__math.html#gga921d656eaf2c4d6800a734a13af021d0aa1d28e08e2f8b49b256e056f93038c1a">AV_ROUND_UP</a></div><div class="ttdeci">@ AV_ROUND_UP</div><div class="ttdoc">Round toward +infinity.</div><div class="ttdef"><b>Definition:</b> mathematics.h:83</div></div>
<div class="ttc" id="agroup__channel__mask__c_html_gabc6d6651bba254cd0fa2c42a57228e65"><div class="ttname"><a href="group__channel__mask__c.html#gabc6d6651bba254cd0fa2c42a57228e65">AV_CH_LAYOUT_STEREO</a></div><div class="ttdeci">#define AV_CH_LAYOUT_STEREO</div><div class="ttdef"><b>Definition:</b> channel_layout.h:91</div></div>
<div class="ttc" id="agroup__lswr_html_ga5121a5a7890a2d23b72dc871dd0ebb06"><div class="ttname"><a href="group__lswr.html#ga5121a5a7890a2d23b72dc871dd0ebb06">swr_get_delay</a></div><div class="ttdeci">int64_t swr_get_delay(struct SwrContext *s, int64_t base)</div><div class="ttdoc">Gets the delay the next input sample will experience relative to the next output sample.</div></div>
<div class="ttc" id="agroup__lavu__mem__funcs_html_ga0cc84043ea2167ad005c86e11d0bcdba"><div class="ttname"><a href="group__lavu__mem__funcs.html#ga0cc84043ea2167ad005c86e11d0bcdba">av_freep</a></div><div class="ttdeci">void av_freep(void *ptr)</div><div class="ttdoc">Free a memory block which has been allocated with a function of av_malloc() or av_realloc() family,...</div></div>
<div class="ttc" id="agroup__lswr_html_gaf58c4ff10f73d74bdab8e5aa7193147c"><div class="ttname"><a href="group__lswr.html#gaf58c4ff10f73d74bdab8e5aa7193147c">swr_alloc</a></div><div class="ttdeci">struct SwrContext * swr_alloc(void)</div><div class="ttdoc">Allocate SwrContext.</div></div>
<div class="ttc" id="agroup__lswr_html_gad7f29022726c871aadf935281a9813bc"><div class="ttname"><a href="group__lswr.html#gad7f29022726c871aadf935281a9813bc">swr_alloc_set_opts</a></div><div class="ttdeci">struct SwrContext * swr_alloc_set_opts(struct SwrContext *s, int64_t out_ch_layout, enum AVSampleFormat out_sample_fmt, int out_sample_rate, int64_t in_ch_layout, enum AVSampleFormat in_sample_fmt, int in_sample_rate, int log_offset, void *log_ctx)</div><div class="ttdoc">Allocate SwrContext if needed and set/reset common parameters.</div></div>
<div class="ttc" id="agroup__channel__mask__c_html_gac36a042dc21866f9043ce930f300d0df"><div class="ttname"><a href="group__channel__mask__c.html#gac36a042dc21866f9043ce930f300d0df">AV_CH_LAYOUT_5POINT1</a></div><div class="ttdeci">#define AV_CH_LAYOUT_5POINT1</div><div class="ttdef"><b>Definition:</b> channel_layout.h:101</div></div>
<div class="ttc" id="agroup__opt__set__funcs_html_ga3adf7185c21cc080890a5ec02c2e56b2"><div class="ttname"><a href="group__opt__set__funcs.html#ga3adf7185c21cc080890a5ec02c2e56b2">av_opt_set_int</a></div><div class="ttdeci">int av_opt_set_int(void *obj, const char *name, int64_t val, int search_flags)</div></div>
<div class="ttc" id="agroup__lavu__math_html_ga82d40664213508918093822461cc597e"><div class="ttname"><a href="group__lavu__math.html#ga82d40664213508918093822461cc597e">av_rescale_rnd</a></div><div class="ttdeci">int64_t av_rescale_rnd(int64_t a, int64_t b, int64_t c, enum AVRounding rnd) av_const</div><div class="ttdoc">Rescale a 64-bit integer with specified rounding.</div></div>
<div class="ttc" id="agroup__opt__set__funcs_html_gaf25f11e11068f2c41197ba072f25d2a4"><div class="ttname"><a href="group__opt__set__funcs.html#gaf25f11e11068f2c41197ba072f25d2a4">av_opt_set_channel_layout</a></div><div class="ttdeci">int av_opt_set_channel_layout(void *obj, const char *name, int64_t ch_layout, int search_flags)</div></div>
<div class="ttc" id="agroup__lswr_html_ga4aa775b7fba31d2c8dc14c7b7e282863"><div class="ttname"><a href="group__lswr.html#ga4aa775b7fba31d2c8dc14c7b7e282863">SwrContext</a></div><div class="ttdeci">struct SwrContext SwrContext</div><div class="ttdoc">The libswresample context.</div><div class="ttdef"><b>Definition:</b> swresample.h:182</div></div>
<div class="ttc" id="agroup__lswr_html_gaa5bb6cab830146efa8c760fa66ee582a"><div class="ttname"><a href="group__lswr.html#gaa5bb6cab830146efa8c760fa66ee582a">swr_convert</a></div><div class="ttdeci">int swr_convert(struct SwrContext *s, uint8_t **out, int out_count, const uint8_t **in, int in_count)</div><div class="ttdoc">Convert audio.</div></div>
<div class="ttc" id="agroup__lavu__sampfmts_html_ggaf9a51ca15301871723577c730b5865c5aea6132df57aebc3f76e10665395c46af"><div class="ttname"><a href="group__lavu__sampfmts.html#ggaf9a51ca15301871723577c730b5865c5aea6132df57aebc3f76e10665395c46af">AV_SAMPLE_FMT_S16</a></div><div class="ttdeci">@ AV_SAMPLE_FMT_S16</div><div class="ttdoc">signed 16 bits</div><div class="ttdef"><b>Definition:</b> samplefmt.h:61</div></div>
<div class="ttc" id="agroup__opt__set__funcs_html_gad446f7a7b92442e464d43e400e661040"><div class="ttname"><a href="group__opt__set__funcs.html#gad446f7a7b92442e464d43e400e661040">av_opt_set_sample_fmt</a></div><div class="ttdeci">int av_opt_set_sample_fmt(void *obj, const char *name, enum AVSampleFormat fmt, int search_flags)</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 11 2021 23:46:38 for foleys_video_engine by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
